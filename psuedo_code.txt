箱庭タウンズの最高地価を求める擬似コード


nが建築物の総個数。

中心建築物は構造体として

	v 地価
	max_lp 残りの外周の最大の連続した長さ

を持つ。

周囲の建築物は構造体として

	l 左端の座標
	r 右端の座標
	t 上端の座標
	bt 下端の座標

を持つ。

各マスは構造体として

	
	// north 上のマス
	// south 下のマス
	// east 東のマス
	// west 西のマス
	building 建築物 //まだ建ってなければempty

を持つ。


Bを建築物全体の集合、v(i)は建築物の地価、v_st(i)は専門街の地価上昇率とする。

再帰関数をrec_st(i, j)とする。iからn番目の建物をjの残りの外周に建築した時の最大の価値とする。

lr(bd)を短辺の長さを求める関数、lr(bd)を長辺の長さを求める関数。(s l = short long, r = rectangle)

建築物jの価値を最大化することを考える。


#attention: 関数の呼び出し回数が非常に多くなりそうなのでメモ化する。

建築物は全部で150個くらい、専門街は200個くらい存在する。外周の最大値は国際空港の36。

Building構造体は、名前、サイズを保持する。

typedef struct building {
	char name[20];
	int long_rect; // rectangle
	int short_rect;
	int value;
	int max_lp;
	} Building;

typedef struct cell {
	// emptyを設定
	} Cell;



int rec_st(Building main_bd) {

int main_bd_size = 2*(main_bd->long_rect) + 2*(main_bd->short_rect);

int dp[147][main_bd_size+1];

bd = n+1 ならば、建てられる建築物が残っていない。
よって、

	res = 0

j->max_lp = 0 ならば、建てられる建築物は残っていない。
よって、

	res = 0

sr(bd) < j -> max_lp ならば、建築物bdは建てられない。
これも

	res = rec_st(b+1, j)

sr(bd) >= max_lp(j) の場合、

	bdを建てないなら、

		res = rec_st(b+1, j)

	bdを建てるなら、

		res = rec_st(b+1, update_lp(j)) + sum{v_st(update_lp(b)} //count_lp は連続部分の最長を更新する関数
								　　	 //update_lp はjの周辺部分の情報を更新する関数

#attention: bdの建築場所の候補は複数ある。

	dp[bd][max_lp(j)] = res;

}

int v_st(Building st_b) {

// やることはだいたい同じ


int st_b_size = 2*(st_b->long_rect) + 2*(st_b->short_rect); // st -> special town 

int dp[147][st_b_size+1];

bd = n+1 ならば、建てられる建築物が残っていない。
よって、

	res = 0

st_b->max_lp = 0 ならば、建てられる建築物は残っていない。
よって、

	res = 0

sr(bd) < j -> max_lp ならば、建築物bdは建てられない。
これも

	res = rec_st(b+1, j)

sr(bd) >= max_lp(j) の場合、

	bdを建てないなら、

		res = rec_st(b+1, j)

	bdを建てるなら、

		res = rec_st(b+1, update_lp(j)) + sum{v_st(update_lp(b)} //count_lp は連続部分の最長を更新する関数
								　　	 //update_lp はjの周辺部分の情報を更新する関数

#attention: bdの建築場所の候補は複数ある。

	dp[bd][max_lp(j)] = res;




}

int main() {

Cell town[150][150]; // マスの配列

}
