// 深さ優先探索で二次元ナップザック問題の拡張を解く。

// 具体的な手順

L, W -> エリアのサイズ

num_bd -> 建築物の種類の数 #回転させたものは別に扱う

Data_Building d_bd[i] (1 < i < num_bd) -> 建築物の情報が詰まった構造体
	char name[100]
	int its_lp -> それ自体の地価
	int affected_lp -> 周囲に与える地価の上昇額
	? increase_lp_area -> 周囲の地価を上昇させる範囲
	int length
	int width 

p, q (0 <= p <= L, 0 <= q <= W) -> 座標

// Building bd[i] -> 建築物(構造体)
	int index_num -> 配列 d_bd内の位置
	int x_lb -> 左下の点のx座標
	int y_lb -> 左下の点のy座標

bool x[i][p][q] (size: [num_bd][L][W]) -> (p,q) を左下の角とする建築物iの存在情報を格納

// bool a[i][p][q] (size: [num_bd][L][W]) -> # 今回必要かどうかわからないので保留

Data_Specialtown d_st[i] (1 < i < num_st) -> 専門街の情報が詰まった構造体


いま、ある物件X0の地価lp(X0)が最も高くなる配置を求めたい。
Xに隣接している物件をX1, ...,Xk、それらの専門街地価上昇率をstlp(X1), ..., stlp(Xk)とする。
すなわち、

	max (its_lp(X0) + sum{affected_lp(Xi)}) * sum{stlp(Xi)}

を求める。条件は、

	物件同士が重ならないこと
	同じ物件数の上限を満たしていること
	X0に道がつながっていること

注意点は
	専門街の重複はカウントしない
	

擬似コードは、

int main{

	//変数や構造体の宣言

	// 国際空港を配置

	

