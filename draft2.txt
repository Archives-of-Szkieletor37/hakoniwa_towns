// 深さ優先探索で二次元ナップザック問題の拡張を解く。

// 具体的な手順

L, W -> エリアのサイズ

num_bd -> 建築物の種類の数 #回転させたものは別に扱う

Data_Building d_bd[i] (1 < i < num_bd) -> 建築物の情報が詰まった構造体
	char name[100]
	int its_lp -> それ自体の地価
	int affected_lp -> 周囲に与える地価の上昇額
	? increase_lp_area -> 周囲の地価を上昇させる範囲
	int length
	int width 

p, q (0 <= p <= L, 0 <= q <= W) -> 座標

Building bd[i] -> 建築物(構造体)
	int index_num -> 配列 d_bd内の位置
	int x_lb -> 左下の点のx座標
	int y_lb -> 左下の点のy座標

Building area[150][150] -> マップ(構造体) #もし何も入ってなければすべての値を-1にする

//bool x[i][p][q] (size: [num_bd][L][W]) -> (p,q) を左下の角とする建築物iの存在情報を格納

// bool a[i][p][q] (size: [num_bd][L][W]) -> # 今回必要かどうかわからないので保留

Data_Specialtown d_st[i] (1 < i < num_st) -> 専門街の情報が詰まった構造体


いま、ある物件X0の地価lp(X0)が最も高くなる配置を求めたい。
Xに隣接している物件をX1, ...,Xk、それらの専門街地価上昇率をstlp(X1), ..., stlp(Xk)とする。
すなわち、

	max (its_lp(X0) + sum{affected_lp(Xi)}) * sum{stlp(Xi)}

を求める。条件は、

	物件同士が重ならないこと
	同じ物件数の上限を満たしていること
	X0に道がつながっていること

注意点は
	専門街の重複はカウントしない
	

擬似コードは、

int main{

	// 変数や構造体の宣言

	// 国際空港を配置

	// まず、隣接させる物件を選びたい。
	
	//ひとつの建築物で、最高でどれだけの専門街を組めるかを計算しておく。1マスの空白のみ残した場合、加えて道も作った場合の2つを考える。
	//かつ、その専門街の塊が何方向に延びているのかを計算しておく。
	
	//国際空港の隣接可能マス35のうちで、もっとも地価上昇率が高くなる隣接物件の組み合わせを選ぶ。
		select_adjacent_buildings(10,8)

	// それらの物件の隣接のさせ方を考える。

	// 隣接させられる候補の座標を算出する。

	// 候補がx種類できたら、1番目のマップに次の候補を隣接させる。


	// 隣接させる物件、マップ、隣接したい候補を引数に取る再帰関数が必要。
	// 隣接したい候補を確認するには、「すでに置かれている建築物の一覧」と「目的とする専門街の一覧」も必要。

	

